import { __assign, __awaiter, __decorate, __generator, __read, __spread } from "tslib";
import { Logger } from '@d-fischer/logger';
import getRawBody from '@d-fischer/raw-body';
import { Enumerable } from '@d-fischer/shared-utils';
import { Server } from 'httpanda';
import { InvalidTokenTypeError } from 'twitch-auth';
import { extractUserId, rtfm } from 'twitch-common';
import { EventSubChannelBanSubscription } from "./Subscriptions/EventSubChannelBanSubscription.mjs";
import { EventSubChannelCheerSubscription } from "./Subscriptions/EventSubChannelCheerSubscription.mjs";
import { EventSubChannelFollowSubscription } from "./Subscriptions/EventSubChannelFollowSubscription.mjs";
import { EventSubChannelHypeTrainBeginSubscription } from "./Subscriptions/EventSubChannelHypeTrainBeginSubscription.mjs";
import { EventSubChannelHypeTrainEndSubscription } from "./Subscriptions/EventSubChannelHypeTrainEndSubscription.mjs";
import { EventSubChannelHypeTrainProgressSubscription } from "./Subscriptions/EventSubChannelHypeTrainProgressSubscription.mjs";
import { EventSubChannelRaidSubscription } from "./Subscriptions/EventSubChannelRaidSubscription.mjs";
import { EventSubChannelRedemptionAddSubscription } from "./Subscriptions/EventSubChannelRedemptionAddSubscription.mjs";
import { EventSubChannelRedemptionUpdateSubscription } from "./Subscriptions/EventSubChannelRedemptionUpdateSubscription.mjs";
import { EventSubChannelRewardAddSubscription } from "./Subscriptions/EventSubChannelRewardAddSubscription.mjs";
import { EventSubChannelRewardRemoveSubscription } from "./Subscriptions/EventSubChannelRewardRemoveSubscription.mjs";
import { EventSubChannelRewardUpdateSubscription } from "./Subscriptions/EventSubChannelRewardUpdateSubscription.mjs";
import { EventSubChannelSubscriptionSubscription } from "./Subscriptions/EventSubChannelSubscriptionSubscription.mjs";
import { EventSubChannelUnbanSubscription } from "./Subscriptions/EventSubChannelUnbanSubscription.mjs";
import { EventSubChannelUpdateSubscription } from "./Subscriptions/EventSubChannelUpdateSubscription.mjs";
import { EventSubStreamOfflineSubscription } from "./Subscriptions/EventSubStreamOfflineSubscription.mjs";
import { EventSubStreamOnlineSubscription } from "./Subscriptions/EventSubStreamOnlineSubscription.mjs";
import { EventSubUserAuthorizationRevokeSubscription } from "./Subscriptions/EventSubUserAuthorizationRevokeSubscription.mjs";
import { EventSubUserUpdateSubscription } from "./Subscriptions/EventSubUserUpdateSubscription.mjs";
var numberRegex = /^\d+$/;
/**
 * A listener for the Twitch EventSub event distribution mechanism.
 */
var EventSubListener = /** @class */ (function () {
    /**
     * Creates a new EventSub listener.
     *
     * @param apiClient The ApiClient instance to use for user info and API requests.
     * @param secret The secret for Twitch to sign payloads with.
     * @param adapter The connection adapter.
     * @param config
     */
    function EventSubListener(apiClient, adapter, secret, config) {
        this._subscriptions = new Map();
        this._twitchSubscriptions = new Map();
        if (apiClient.tokenType !== 'app') {
            throw new InvalidTokenTypeError('EventSub requires app access tokens to work; please use the ClientCredentialsAuthProvider in your API client.');
        }
        this._apiClient = apiClient;
        this._secret = secret;
        this._adapter = adapter;
        this._logger = new Logger(__assign({ name: 'twitch-eventsub', emoji: true }, config === null || config === void 0 ? void 0 : config.logger));
    }
    /**
     * Starts the backing server and listens to incoming EventSub notifications.
     */
    EventSubListener.prototype.listen = function (port) {
        var _a;
        return __awaiter(this, void 0, Promise, function () {
            var server, adapterListenerPort, listenerPort;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this._server) {
                            throw new Error('Trying to listen while already listening');
                        }
                        server = this._adapter.createHttpServer();
                        this._server = new Server({
                            server: server,
                            onError: function (e, req) {
                                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                                if (e.code === 404) {
                                    _this._logger.warn("Access to unknown URL/method attempted: " + req.method + " " + req.url);
                                }
                            }
                        });
                        // needs to be first in chain but run last, for proper logging of status
                        this._server.use(function (req, res, next) {
                            setImmediate(function () {
                                _this._logger.debug(req.method + " " + req.path + " - " + res.statusCode);
                            });
                            next();
                        });
                        this._server.post('/:id', this._createHandleRequest());
                        return [4 /*yield*/, this._adapter.getListenerPort()];
                    case 1:
                        adapterListenerPort = _b.sent();
                        if (adapterListenerPort && port) {
                            this._logger.warn("Your passed port (" + port + ") is being ignored because the adapter has overridden it.\nListening on port " + adapterListenerPort + " instead.");
                        }
                        listenerPort = (_a = adapterListenerPort !== null && adapterListenerPort !== void 0 ? adapterListenerPort : port) !== null && _a !== void 0 ? _a : 443;
                        return [4 /*yield*/, this._server.listen(listenerPort)];
                    case 2:
                        _b.sent();
                        this._currentListenerPort = listenerPort;
                        this._logger.info("Listening on port " + listenerPort);
                        return [4 /*yield*/, this.resumeExistingSubscriptions()];
                    case 3:
                        _b.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Resumes subscriptions that are already registered with Twitch.
     */
    EventSubListener.prototype.resumeExistingSubscriptions = function () {
        return __awaiter(this, void 0, Promise, function () {
            var subscriptions, urlPrefix;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._apiClient.helix.eventSub.getSubscriptionsPaginated().getAll()];
                    case 1:
                        subscriptions = _a.sent();
                        return [4 /*yield*/, this._buildHookUrl('')];
                    case 2:
                        urlPrefix = _a.sent();
                        this._twitchSubscriptions = new Map(subscriptions
                            .map(function (sub) {
                            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                            if (sub._transport.method === 'webhook') {
                                var url = sub._transport.callback;
                                if (url.startsWith(urlPrefix)) {
                                    var id = url.slice(urlPrefix.length);
                                    return [id, sub];
                                }
                            }
                            return undefined;
                        })
                            .filter(function (x) { return !!x; }));
                        return [4 /*yield*/, Promise.all(__spread(this._subscriptions).map(function (_a) {
                                var _b = __read(_a, 2), subId = _b[0], sub = _b[1];
                                return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_c) {
                                    return [2 /*return*/, sub.start(this._twitchSubscriptions.get(subId))];
                                }); });
                            }))];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Stops the backing server, suspending all active subscriptions.
     */
    EventSubListener.prototype.unlisten = function () {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._server) {
                            throw new Error('Trying to unlisten while not listening');
                        }
                        return [4 /*yield*/, Promise.all(__spread(this._subscriptions.values()).map(function (sub) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2 /*return*/, sub.suspend()];
                            }); }); }))];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this._server.close()];
                    case 2:
                        _a.sent();
                        this._server = undefined;
                        this._currentListenerPort = undefined;
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Applies middleware that handles EventSub notifications to a connect-compatible app (like express).
     *
     * The express app should be started before this.
     *
     * @param app The app the middleware should be applied to.
     */
    EventSubListener.prototype.applyMiddleware = function (app) {
        return __awaiter(this, void 0, Promise, function () {
            var pathPrefix, paramParser, requestHandler;
            return __generator(this, function (_a) {
                pathPrefix = this._adapter.pathPrefix;
                if (pathPrefix) {
                    pathPrefix = "/" + pathPrefix.replace(/^\/|\/$/, '');
                }
                paramParser = function (req, res, next) {
                    var _a = __read(req.path.split('/'), 2), id = _a[1];
                    req.param = req.params = { id: id };
                    next();
                };
                requestHandler = this._createHandleRequest();
                if (pathPrefix) {
                    app.use(pathPrefix, paramParser, requestHandler);
                }
                else {
                    app.use(paramParser, requestHandler);
                }
                // stub to fix subscription registration
                this._currentListenerPort = -1;
                return [2 /*return*/];
            });
        });
    };
    /**
     * Subscribes to events representing a stream going live.
     *
     * @param user The user for which to get notifications about their streams going live.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToStreamOnlineEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToStreamOnlineEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubStreamOnlineSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events representing a stream going offline.
     *
     * @param user The user for which to get notifications about their streams going offline.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToStreamOfflineEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToStreamOfflineEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubStreamOfflineSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events representing a change in channel metadata, e.g. stream title or category.
     *
     * @param user The user for which to get notifications about updates.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelUpdateEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelUpdateSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user following a channel.
     *
     * @param user The user for which to get notifications about their followers.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelFollowEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelFollowEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelFollowSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user subscribing to a channel.
     *
     * @param user The user for which to get notifications for about their subscribers.
     * @param handler  The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelSubscriptionEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelSubscribeEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelSubscriptionSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user cheering some bits.
     *
     * @param user The user for which to get notifications for about cheers they get.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelCheerEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelCheerEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelCheerSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user getting banned from a channel.
     *
     * @param user The user for which to get notifications for when users get banned in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelBanEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelBanEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelBanSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user getting unbanned from a channel.
     *
     * @param user The user for which to get notifications for when users get unbanned in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelUnbanEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelUnbanEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelUnbanSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a broadcaster raiding another broadcaster.
     *
     * @param user The broadcaster for which to get outgoing raid notifications.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelRaidEventsFrom = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRaidEventsFrom: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRaidSubscription, handler, this, userId, 'from')];
            });
        });
    };
    /**
     * Subscribes to events that represent a broadcaster being raided by another broadcaster.
     *
     * @param user The broadcaster for which to get incoming raid notifications.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelRaidEventsTo = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRaidEventsTo: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRaidSubscription, handler, this, userId, 'to')];
            });
        });
    };
    /**
     * Subscribes to events that represent a Channel Points reward being added to a channel.
     *
     * @param user The user for which to get notifications for when they add a reward to their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelRewardAddEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRewardAddEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRewardAddSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a Channel Points reward being updated.
     *
     * @param user The user for which to get notifications for when they update a reward.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelRewardUpdateEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToRewardUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRewardUpdateSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a specific Channel Points reward being updated.
     *
     * @param user The user for which to get notifications for when they update the reward.
     * @param rewardId The ID of the reward for which to get notifications when it is updated.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelRewardUpdateEventsForReward = function (user, rewardId, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToRewardUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRewardUpdateSubscription, handler, this, userId, rewardId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a Channel Points reward being removed.
     *
     * @param user The user for which to get notifications for when they remove a reward.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelRewardRemoveEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToRewardRemoveEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRewardRemoveSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a specific Channel Points reward being removed.
     *
     * @param user The user for which to get notifications for when they remove the reward.
     * @param rewardId The ID of the reward to get notifications for when it is removed.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelRewardRemoveEventsForReward = function (user, rewardId, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToRewardRemoveEventsForReward: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRewardRemoveSubscription, handler, this, userId, rewardId)];
            });
        });
    };
    /**
     * Subscribes to events that represents a Channel Points reward being redeemed.
     *
     * @param user The user for which to get notifications for when their rewards are redeemed.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelRedemptionAddEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRedemptionEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRedemptionAddSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a specific Channel Points reward being redeemed.
     *
     * @param user The user for which to get notifications when their reward is redeemed.
     * @param rewardId The ID of the reward for which to get notifications when it is redeemed.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelRedemptionAddEventsForReward = function (user, rewardId, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToRedemptionAddEventsForReward: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRedemptionAddSubscription, handler, this, userId, rewardId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a Channel Points reward being updated by a broadcaster.
     *
     * @param user The user for which to get notifications for when they update a reward.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelRedemptionUpdateEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRedemptionUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRedemptionUpdateSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a specific Channel Points reward being updated by a broadcaster.
     *
     * @param user The user for which to get notifications for when they update the reward.
     * @param rewardId The ID of the reward for which to get notifications when it gets updated.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelRedemptionUpdateEventsForReward = function (user, rewardId, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelRedemptionUpdateEventsForReward: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelRedemptionUpdateSubscription, handler, this, userId, rewardId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a Hype Train beginning.
     *
     * @param user The user for which to get notifications about Hype Trains in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelHypeTrainBeginEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelHypeTrainBeginEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelHypeTrainBeginSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent progress in a Hype Train in a channel.
     *
     * @param user The user for which to get notifications about Hype Trains in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelHypeTrainProgressEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelHypeTrainProgressEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelHypeTrainProgressSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent the end of a Hype Train in a channel.
     *
     * @param user The user for which to get notifications about Hype Trains in their channel.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToChannelHypeTrainEndEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToChannelHypeTrainEndEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubChannelHypeTrainEndSubscription, handler, this, userId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user revoking authorization from an application.
     *
     * @param clientId The Client ID for which to get notifications about authorization revocations.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToUserAuthorizationRevokeEvents = function (clientId, handler) {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._genericSubscribe(EventSubUserAuthorizationRevokeSubscription, handler, this, clientId)];
            });
        });
    };
    /**
     * Subscribes to events that represent a user updating their account details.
     *
     * @param user The user for which to get notifications about account updates.
     * @param handler The function that will be called for any new notifications.
     */
    EventSubListener.prototype.subscribeToUserUpdateEvents = function (user, handler) {
        return __awaiter(this, void 0, Promise, function () {
            var userId;
            return __generator(this, function (_a) {
                userId = extractUserId(user);
                if (!numberRegex.test(userId)) {
                    this._logger.warn('EventSubListener#subscribeToUserUpdateEvents: The given user is a non-numeric string. You might be sending a user name instead of a user ID.');
                }
                return [2 /*return*/, this._genericSubscribe(EventSubUserUpdateSubscription, handler, this, userId)];
            });
        });
    };
    /** @private */
    EventSubListener.prototype._buildHookUrl = function (id) {
        var _a, _b;
        return __awaiter(this, void 0, Promise, function () {
            var hostName, externalPort, hostPortion, pathPrefix;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this._adapter.getHostName()];
                    case 1:
                        hostName = _c.sent();
                        return [4 /*yield*/, this._adapter.getExternalPort()];
                    case 2:
                        externalPort = (_a = (_c.sent())) !== null && _a !== void 0 ? _a : this._currentListenerPort;
                        if (!externalPort) {
                            throw new Error('Can not build hook URL with implicit external port while not listening');
                        }
                        hostPortion = externalPort === 443 ? hostName : hostName + ":" + externalPort;
                        pathPrefix = (_b = this._adapter.pathPrefix) === null || _b === void 0 ? void 0 : _b.replace(/^\/|\/$/, '');
                        return [2 /*return*/, "https://" + hostPortion + (pathPrefix ? '/' : '') + (pathPrefix !== null && pathPrefix !== void 0 ? pathPrefix : '') + "/" + id];
                }
            });
        });
    };
    /** @private */
    EventSubListener.prototype._dropSubscription = function (id) {
        this._subscriptions.delete(id);
    };
    /** @private */
    EventSubListener.prototype._dropTwitchSubscription = function (id) {
        this._twitchSubscriptions.delete(id);
    };
    /** @private */
    EventSubListener.prototype._registerTwitchSubscription = function (id, data) {
        this._twitchSubscriptions.set(id, data);
    };
    EventSubListener.prototype._genericSubscribe = function (clazz, handler, client) {
        var params = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            params[_i - 3] = arguments[_i];
        }
        return __awaiter(this, void 0, Promise, function () {
            var subscription;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        subscription = new (clazz.bind.apply(clazz, __spread([void 0, handler, client], params)))();
                        if (!this._currentListenerPort) return [3 /*break*/, 2];
                        return [4 /*yield*/, subscription.start(this._twitchSubscriptions.get(subscription.id))];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        this._subscriptions.set(subscription.id, subscription);
                        return [2 /*return*/, subscription];
                }
            });
        });
    };
    EventSubListener.prototype._createHandleRequest = function () {
        var _this = this;
        return function (req, res, next) { return __awaiter(_this, void 0, void 0, function () {
            var id, subscription, twitchSubscription, type, messageId, timestamp, body, algoAndSignature, verified, data, verificationBody;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        id = req.param.id;
                        subscription = this._subscriptions.get(id);
                        twitchSubscription = this._twitchSubscriptions.get(id);
                        type = req.headers['twitch-eventsub-message-type'];
                        if (!subscription) return [3 /*break*/, 2];
                        messageId = req.headers['twitch-eventsub-message-id'];
                        timestamp = req.headers['twitch-eventsub-message-timestamp'];
                        return [4 /*yield*/, getRawBody(req, true)];
                    case 1:
                        body = _a.sent();
                        algoAndSignature = req.headers['twitch-eventsub-message-signature'];
                        if (algoAndSignature === undefined) {
                            this._logger.warn("Dropping unsigned message for action " + type + " of event: " + id);
                            res.writeHead(410);
                            res.end();
                        }
                        else {
                            verified = subscription._verifyData(messageId, timestamp, body, algoAndSignature);
                            if (verified) {
                                data = JSON.parse(body);
                                if (type === 'webhook_callback_verification') {
                                    verificationBody = data;
                                    subscription._verify();
                                    if (twitchSubscription) {
                                        twitchSubscription._status = 'enabled';
                                    }
                                    res.setHeader('Content-Length', verificationBody.challenge.length);
                                    res.writeHead(200, undefined);
                                    res.end(verificationBody.challenge);
                                    this._logger.debug("Successfully subscribed to event: " + id);
                                }
                                else if (type === 'notification') {
                                    subscription._handleData(data.event);
                                    res.writeHead(202);
                                    res.end();
                                }
                                else {
                                    this._logger.warn("Unknown action " + type + " for event: " + id);
                                    res.writeHead(400);
                                    res.end();
                                }
                            }
                            else {
                                this._logger.warn("Could not verify action " + type + " of event: " + id);
                                res.writeHead(410);
                                res.end();
                            }
                        }
                        return [3 /*break*/, 3];
                    case 2:
                        this._logger.warn("Action " + type + " of unknown event attempted: " + id);
                        res.writeHead(410);
                        res.end();
                        _a.label = 3;
                    case 3:
                        next();
                        return [2 /*return*/];
                }
            });
        }); };
    };
    __decorate([
        Enumerable(false)
    ], EventSubListener.prototype, "_server", void 0);
    __decorate([
        Enumerable(false)
    ], EventSubListener.prototype, "_subscriptions", void 0);
    __decorate([
        Enumerable(false)
    ], EventSubListener.prototype, "_twitchSubscriptions", void 0);
    __decorate([
        Enumerable(false)
    ], EventSubListener.prototype, "_apiClient", void 0);
    __decorate([
        Enumerable(false)
    ], EventSubListener.prototype, "_secret", void 0);
    EventSubListener = __decorate([
        rtfm('twitch-eventsub', 'EventSubListener')
    ], EventSubListener);
    return EventSubListener;
}());
export { EventSubListener };
