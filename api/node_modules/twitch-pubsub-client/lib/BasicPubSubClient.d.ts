/// <reference types="ws" />
import type { ClientOptions } from '@d-fischer/isomorphic-ws';
import type { LoggerOptions } from '@d-fischer/logger';
import type { ResolvableValue } from '@d-fischer/shared-utils';
import type { Listener } from '@d-fischer/typed-event-emitter';
import { EventEmitter } from '@d-fischer/typed-event-emitter';
import type { AuthProvider } from 'twitch-auth';
import type { PubSubMessageData } from './Messages/PubSubMessage';
/** @private */
interface NullTokenResolvable {
    type: 'null';
}
/** @private */
interface StaticTokenResolvable {
    type: 'static';
    token: string;
}
/** @private */
interface FunctionTokenResolvable {
    type: 'function';
    function: () => string | Promise<string>;
}
/** @private */
interface ProviderTokenResolvable {
    type: 'provider';
    provider: AuthProvider;
    scopes: string[];
}
/** @private */
declare type TokenResolvable = NullTokenResolvable | StaticTokenResolvable | FunctionTokenResolvable | ProviderTokenResolvable;
/**
 * Options for the basic PubSub client.
 */
export interface BasicPubSubClientOptions {
    /**
     * Options to pass to the logger.
     */
    logger?: Partial<LoggerOptions>;
    /**
     * The client options to use for connecting to the WebSocket.
     */
    wsOptions?: ClientOptions;
}
/**
 * A client for the Twitch PubSub interface.
 */
export declare class BasicPubSubClient extends EventEmitter {
    private readonly _logger;
    private readonly _topics;
    private readonly _connection;
    private readonly _pingOnInactivity;
    private readonly _pingTimeout;
    private _pingCheckTimer?;
    private _pingTimeoutTimer?;
    private readonly _onPong;
    private readonly _onResponse;
    /**
     * Fires when a message that matches your listening topics is received.
     *
     * @eventListener
     * @param topic The name of the topic.
     * @param message The message data.
     */
    readonly onMessage: (handler: (topic: string, message: PubSubMessageData) => void) => Listener;
    /**
     * Fires when the client finishes establishing a connection to the PubSub server.
     *
     * @eventListener
     */
    readonly onConnect: (handler: () => void) => Listener;
    /**
     * Fires when the client closes its connection to the PubSub server.
     *
     * @eventListener
     * @param isError Whether the cause of the disconnection was an error. A reconnect will be attempted if this is true.
     */
    readonly onDisconnect: (handler: (isError: boolean, reason?: Error) => void) => Listener;
    /**
     * Fires when the client receives a pong message from the PubSub server.
     *
     * @eventListener
     * @param latency The current latency to the server, in milliseconds.
     * @param requestTimestampe The time the ping request was sent to the PubSub server.
     */
    readonly onPong: (handler: (latency: number, requestTimestamp: number) => void) => Listener;
    /**
     * Creates a new PubSub client.
     *
     * @param options
     *
     * @expandParams
     */
    constructor(options?: BasicPubSubClientOptions);
    /**
     * Listens to one or more topics.
     *
     * @param topics A topic or a list of topics to listen to.
     * @param tokenResolvable An access token, an AuthProvider or a function that returns a token.
     * @param scope The scope necessary for the topic(s).
     */
    listen(topics: string | string[], tokenResolvable?: ResolvableValue<string> | AuthProvider | TokenResolvable | null, scope?: string): Promise<void>;
    /**
     * Removes one or more topics from the listener.
     *
     * @param topics A topic or a list of topics to not listen to anymore.
     */
    unlisten(topics: string | string[]): Promise<void>;
    /**
     * Connects to the PubSub interface.
     */
    connect(): Promise<void>;
    /**
     * Disconnects from the PubSub interface.
     */
    disconnect(): Promise<void>;
    /**
     * Reconnects to the PubSub interface.
     */
    reconnect(): Promise<void>;
    /**
     * Checks whether the client is currently connecting to the server.
     */
    get isConnecting(): boolean;
    /**
     * Checks whether the client is currently connected to the server.
     */
    get isConnected(): boolean;
    /** @private */
    get hasAnyTopics(): boolean;
    private _sendListen;
    private _sendUnlisten;
    private static _wrapResolvable;
    private _resolveToken;
    private _resendListens;
    private _sendNonced;
    private _receiveMessage;
    private _sendPacket;
    private _pingCheck;
    private _startPingCheckTimer;
}
export {};
